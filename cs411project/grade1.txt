25/25% - Mechanics (submitted, compiles, readme)
    5/5% - submitted on time
    5/5% - multiple commits
    5/5% - readme present and informative
    5/5% - compiles
    5/5% - fills memory with assembled codes
 9/ 9% - I/O
    3/3% - Wait for enter each clock cycle
    3/3% - Print one of M, R, A, D, F or N each cycle
    3/3% - On A or D, wait for a response
15/18% - Decoding
	3/3% - Opcode/func/Cfn decoded
    3/3% - Register 0 returns 0, even after write
    3/3% - Correct register numbers decoded for rs, rt, rd, as needed
    3/3% - Unsigned/positive immediate extended with 0's
    0/3% - Negative immediate sign extended [1]
    3/3% - Jump address decoded [2]
12/12% - C-type
    3/3% - spd, rot, fir add register value to immediate
    3/3% - spd, rot, fir output correct letter and value
    3/3% - ascn, dscn output correct letter
    3/3% - ascn, dscn assign value into given register
15/18% - I-type
    3/3% - ALU ops (addi, addiu, andi, ori, xori, lui) do correct operations
    3/3% - ALU ops read from and write to correct registers
    3/3% - Branch (beq, bne, blez, bgtz) branch on correct conditions
    0/3% - Branch to correct target [3]
    3/3% - sw, lw to correct address (register value plus immediate)
    3/3% - sw, lw can write then read values
 6/ 6% - J-type
    3/3% - j, jal jump to correct target
    3/3% - jal writes return address to $31
11/12% - R-type
    3/3% - ALU ops (add, addu, sub, subu, and, or, xor, nor) do correct ops
    3/3% - ALU ops read from and write to correct registers
    2/3% - jr, jalr jump to correct target [4]
    3/3% - jalr writes return address to $31
------
 93/100% Total

[1] rot #-1($0) prints R 65535, should print R -1

[2] jump addresses not *encoded* correctly by the assembler, but are
decoded correctly

[3] branches don't add current PC to offset

[4] jalr doesn't work if target is register 31

10/10% - Mechanics (submitted, readme)
  5/5% - submitted on time
  5/5% - readme present and informative
20/20% - Datapath structure
  5/5% - Single memory unit
  5/5% - Nothing impossible
  5/5% - All necessary multiplexers
  5/5% - Capable of all instructions
9/15% - Datapath Timing
  2/5% - Unit timings [1]
  5/5% - Feasible multi-cycle division
  2/5% - Per cycle timing, valid clock [2]
9/15% - RTL mechanics
  2/5% - Shared IF and ID [3]
  5/5% - Per-operation cycles
  2/5% - Return to IF for next instruction [4]
35/40% - RTL specifics
  4/5% - R-type jump: jr, jalr [5]
  5/5% - R-type ALU: add, addu, sub, subu, and, or, xor, nor [6]
  5/5% - J-type: j, jal [5]
  5/5% - I-type branch: beq, bne, blez, bgtz
  4/5% - I-type ALU: addi, addiu, andi, ori, xori, lui [7]
  4/5% - I-type mem: lw, sw [8,9]
  4/5% - C-type output: spd, rot, fir [10]
  4/5% - C-type input: ascn, dscn [10]
------
83/100% Total

[1] Many units seem to use the wrong timing. ALUs are less than 14,
Some 2-input multiplexers are 4 instead of 2. Register file write and
read off.

[2] Timing sums don't work out. See diagram. Looks like 27 would be
the fastest valid clock.

[3] IF listed per instruction, though it cannot know the instruction
yet. IF does not handle multiple cycles of memory fetch.

[4] State transition not modeled

[5] jalr and jal: return address should be NPC, not NPC+4. you also do
not need the extra adder in ID for this addition.

[6] NOR is ~(x|y). Not deducting points for that though, as you
clearly have the architecture idea down.

[7] LUI needs to shift imm by 16. You have the shift and mux for this,
but don't use it in your RTL.

[8] LW needs to use MemDataReg

[9] LW, SW do not handle multiple cycles for fetch

[10] Robot instructions do not indicate multiple cycles for robot unit
